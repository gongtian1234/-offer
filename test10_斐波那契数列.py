'''
面试题10：斐波那契数列
题目一：求斐波那契数列的第n项。写一个函数，输入n，求斐波那契数列(Fibonacci)的第n项。
【斐波那契数列：f_0=0, f_1=1, f_2=f_0+f_1=1, f_3=f_2+f_1=1+1=2, f_4=f_3+f_2=2+1=3, 以此类推】

题目二：青蛙跳台阶问题。一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶，求一只青蛙跳上n级台阶总共有多少总跳法。

思路：
题目一：
首先想到的方法就是用递归的方式，从上至下的求解，而且递归的方式demo简捷，但是递归的方式每次都会重新计算一遍，会增加徒劳的计算量；
进一步升级用循环的方式从下至上求解，前面的值可以保存下来供后面使用，算法复杂度为O(n), 而且性能更优计算n=3000都没问题，而递归n=30就开始卡了;

题目二：
这道题的关键在于怎么把该问题转换为斐波那契数列的问题。
把n级台阶的跳法看作n的函数，记为f(n), 若第一次跳1级，剩下f(n-1); 若第一次跳2级，剩下f(n-2), 所以n级台阶的跳法为f(n)=f(n-1)+f(n-2)

相关题目：用一个2*1的矩形去覆盖2*8的矩形，问有多少种覆盖方法？

总结（仅供参考）：可以转换为斐波那契数列的问题通常具有以下特征：
1.涉及1或2（倍数也行）；
2.最后问有多少种方法；
3.遇到满足上述条件的，一定要用循环去解题，用递归性能严重不足。
'''

class Solution:
    def recursive_method(self, n):
        # 使用递归的方法解题
        if n==0:
            return 0
        elif n==1:
            return 1
        else:
            return self.recursive_method(n-1) + self.recursive_method(n-2)

    def for_method(self, n):
        # 使用循环的方式解题
        if n==0:
            return 0
        elif n==1:
            return 1
        else:
            lst = [0,1]
            for i in range(2, n+1):
                f_i = lst[i-1] + lst[i-2]
                lst.append(f_i)
            return f_i

test = Solution()
print(test.recursive_method(5))    # 递归的方式30还勉强，40则卡不出来了
print(test.for_method(300))          # for循环的方式，到1000都能求解出结果
